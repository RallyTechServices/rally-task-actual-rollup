<!DOCTYPE html>
<html>
<head>
    <title>Task Actual Rollup</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Mon Dec 22 2014 15:18:06 GMT-0800 (PST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Dec 22 2014 15:18:06 GMT-0800 (PST)";
        var CHECKSUM = 25442432171;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

/* Blob.js
 * A Blob implementation.
 * 2014-05-31
 * 
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

(function (view) {
	"use strict";

	view.URL = view.URL || view.webkitURL;

	if (view.Blob && view.URL) {
		try {
			new Blob;
			return;
		} catch (e) {}
	}

	// Internally we use a BlobBuilder implementation to base Blob off of
	// in order to support older browsers that only have BlobBuilder
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
		var
			  get_class = function(object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			}
			, FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			}
			, FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			}
			, FBB_proto = FakeBlobBuilder.prototype
			, FB_proto = FakeBlob.prototype
			, FileReaderSync = view.FileReaderSync
			, FileException = function(type) {
				this.code = this[this.name = type];
			}
			, file_ex_codes = (
				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
			).split(" ")
			, file_ex_code = file_ex_codes.length
			, real_URL = view.URL || view.webkitURL || view
			, real_create_object_URL = real_URL.createObjectURL
			, real_revoke_object_URL = real_URL.revokeObjectURL
			, URL = real_URL
			, btoa = view.btoa
			, atob = view.atob
			
			, ArrayBuffer = view.ArrayBuffer
			, Uint8Array = view.Uint8Array
		;
		FakeBlob.fake = FB_proto.fake = true;
		while (file_ex_code--) {
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
		}
		if (!real_URL.createObjectURL) {
			URL = view.URL = {};
		}
		URL.createObjectURL = function(blob) {
			var
				  type = blob.type
				, data_URI_header
			;
			if (type === null) {
				type = "application/octet-stream";
			}
			if (blob instanceof FakeBlob) {
				data_URI_header = "data:" + type;
				if (blob.encoding === "base64") {
					return data_URI_header + ";base64," + blob.data;
				} else if (blob.encoding === "URI") {
					return data_URI_header + "," + decodeURIComponent(blob.data);
				} if (btoa) {
					return data_URI_header + ";base64," + btoa(blob.data);
				} else {
					return data_URI_header + "," + encodeURIComponent(blob.data);
				}
			} else if (real_create_object_URL) {
				return real_create_object_URL.call(real_URL, blob);
			}
		};
		URL.revokeObjectURL = function(object_URL) {
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
				real_revoke_object_URL.call(real_URL, object_URL);
			}
		};
		FBB_proto.append = function(data/*, endings*/) {
			var bb = this.data;
			// decode data to a binary string
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
				var
					  str = ""
					, buf = new Uint8Array(data)
					, i = 0
					, buf_len = buf.length
				;
				for (; i < buf_len; i++) {
					str += String.fromCharCode(buf[i]);
				}
				bb.push(str);
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
				if (FileReaderSync) {
					var fr = new FileReaderSync;
					bb.push(fr.readAsBinaryString(data));
				} else {
					// async FileReader won't work as BlobBuilder is sync
					throw new FileException("NOT_READABLE_ERR");
				}
			} else if (data instanceof FakeBlob) {
				if (data.encoding === "base64" && atob) {
					bb.push(atob(data.data));
				} else if (data.encoding === "URI") {
					bb.push(decodeURIComponent(data.data));
				} else if (data.encoding === "raw") {
					bb.push(data.data);
				}
			} else {
				if (typeof data !== "string") {
					data += ""; // convert unsupported types to strings
				}
				// decode UTF-16 to binary string
				bb.push(unescape(encodeURIComponent(data)));
			}
		};
		FBB_proto.getBlob = function(type) {
			if (!arguments.length) {
				type = null;
			}
			return new FakeBlob(this.data.join(""), type, "raw");
		};
		FBB_proto.toString = function() {
			return "[object BlobBuilder]";
		};
		FB_proto.slice = function(start, end, type) {
			var args = arguments.length;
			if (args < 3) {
				type = null;
			}
			return new FakeBlob(
				  this.data.slice(start, args > 1 ? end : this.data.length)
				, type
				, this.encoding
			);
		};
		FB_proto.toString = function() {
			return "[object Blob]";
		};
		FB_proto.close = function() {
			this.size = 0;
			delete this.data;
		};
		return FakeBlobBuilder;
	}(view));

	view.Blob = function Blob(blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				builder.append(blobParts[i]);
			}
		}
		return builder.getBlob(type);
	};
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
/* FileSaver.js
 *  A saveAs() FileSaver implementation.
 *  2014-05-27
 *
 *  By Eli Grey, http://eligrey.com
 *  License: X11/MIT
 *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  // IE 10+ (native saveAs)
  || (typeof navigator !== "undefined" &&
      navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  // Everyone else
  || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" &&
	    /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = !view.externalHost && "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		, deletion_queue = []
		, process_deletion_queue = function() {
			var i = deletion_queue.length;
			while (i--) {
				var file = deletion_queue[i];
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			}
			deletion_queue.length = 0; // clear queue
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, get_object_url = function() {
					var object_url = get_URL().createObjectURL(blob);
					deletion_queue.push(object_url);
					return object_url;
				}
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_object_url(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						window.open(object_url, "_blank");
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_object_url(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									deletion_queue.push(file);
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	view.addEventListener("unload", process_deletion_queue, false);
	saveAs.unload = function() {
		process_deletion_queue();
		view.removeEventListener("unload", process_deletion_queue, false);
	};
	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module !== null) {
  module.exports = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    calculation_fields: { 'PlanEstimate': 'Plan Estimate', 'TaskActualTotal': 'Actual' ,'TaskEstimateTotal':'Estimate','TaskRemainingTotal':'To Do'},
    items: [
        {xtype:'container',itemId:'selector_box', margin: 10},
        {xtype:'container',itemId:'display_box', margin: 10},
        {xtype:'tsinfolink'}
    ],
    launch: function() {
        this.setLoading('Gathering data...');
        
        this._getPortfolioItemTypes().then({
            scope: this,
            success:function(types) {
                this.pi_types = types;
                var lowest_type = types[0];
                
                this._loadStories(lowest_type.get('ElementName')).then({
                    scope: this,
                    success: function(stories){
                        this._addParentInformation(stories,lowest_type.get('ElementName')).then({
                            scope: this,
                            success: function(parents) {
                                var records = this._consolidateParentInfoInStories(stories,parents);
                                
                                var top_type = types[types.length - 1].get('Name');
                                
                                var store = Ext.create('Rally.data.custom.Store',{
                                    data: records,
                                    sorters: [{property: top_type + "_ObjectID"}]
                                });
//                                
                                var columns = [];
                                columns.push( {dataIndex:'workspace_name', text:'Workspace' } );
                                columns.push( {dataIndex:'program_name', text:'Program' } );
                                columns.push( {dataIndex:'project_name', text:'Project' } );
                                
                                for ( var i=this.pi_types.length; i>0; i-- ) {
                                    var sub_columns = [];
                                    var type = this.pi_types[i-1].get('ElementName');
                                    sub_columns.push({
                                        dataIndex:type + "_FormattedID",
                                        text: " id", width: 50,
                                        csvText: type + " id"
                                    });
                                    sub_columns.push({
                                        dataIndex:type + "_Name",
                                        text: "Name", width: 150,
                                        csvText: type + " Name"
                                    });
                                    Ext.Object.each(this.calculation_fields,function(calculation_field,calculation_header){
                                        sub_columns.push({
                                            dataIndex:type + "_" +calculation_field,
                                            text: calculation_header,
                                            csvText: type + " " + calculation_header
                                        });
                                    });
                                    columns.push({ text: type, columns: sub_columns });
                                }
                                Ext.Array.push(columns, [
                                    { 
                                        text: "Story", 
                                        columns: [
                                            {dataIndex:'FormattedID',text:'id', width: 50}, 
                                            {dataIndex:'Name',text:'Name',width: 200},
                                            {dataIndex: 'PlanEstimate', text:'Plan Estimate (Pts)'},
                                            {dataIndex: 'TaskEstimateTotal', text:'Estimate Hours'},
                                            {dataIndex: 'TaskActualTotal', text:'Actual Hours'},
                                            {dataIndex: 'TaskRemainingTotal', text:'To Do'}
                                        ]
                                    }
                                ]);
                                
                                var grid = this.down('#display_box').add({
                                    xtype: 'rallygrid',
                                    store: store,
                                    sortableColumns: false,
                                    columnCfgs: columns
                                });
                                this._addButton(grid,records); 
                                this.setLoading(false);
                            },
                            failure: function(error_message) {
                                alert(error_message);
                            }
                        });
                    },
                    failure: function(error_message){
                        alert(error_message);
                    }
                });
            },
            failure: function(msg) {
                alert(msg);
            }
        });
        
        
    },
    _addButton: function(grid,records) {
        if ( this._isAbleToDownloadFiles() ) {
            this.down('#selector_box').add({
                xtype:'rallybutton',
                itemId:'save_button',
                text:'Save As CSV',
                scope: this,
                handler: function() {
                    var csv = this._getCSVFromGrid(grid,records);
                    this._saveCSVToFile(csv,'task-summary.csv',{type:'text/csv;charset=utf-8'});
                }
            });
        }
    },
    _addParentInformation: function(records,parent_field) {
        var deferred = Ext.create('Deft.Deferred');
        
        var parent_oids = [];
        Ext.Array.each(records,function(record){ 
            if ( record.get(parent_field)) {
                var parent_oid = record.get(parent_field).ObjectID;
                if ( parent_oid ) {
                    parent_oids = Ext.Array.merge(parent_oids,[parent_oid]); 
                }
            }
        });
        
        var parent_type = 'PortfolioItem/' + parent_field;
        
        this._loadItemsByObjectID(parent_oids,parent_type,[]).then({
            scope: this,
            success: function(parents){
                var item_hash = {};
                Ext.Array.each(parents, function(parent){
                    item_hash[parent.get('ObjectID')] = parent;
                });
                // calculate rollups for direct parents
                Ext.Array.each(records,function(child) {
                    var parent_link = child.get(parent_field);
                    if ( parent_link ) {
                        var parent = item_hash[parent_link.ObjectID];
                        Ext.Object.each(this.calculation_fields,function(calculation_field,calculation_header){
                            var parent_value = parent.get(calculation_field) || 0;
                            var child_value = child.get(calculation_field) || 0;
                            parent.set(calculation_field,parent_value+child_value);
                        });
                    }
                },this);
                // cycle through parent types to roll up data
                this.logger.log("pi types:", this.pi_types);
                Ext.Array.each(this.pi_types, function(pi_type) {
                    this.logger.log('pi type:', pi_type);
                    Ext.Object.each(item_hash, function(key,child){
                        this.logger.log('key,value', key, child);
                        if ( Ext.util.Format.lowercase(pi_type.get('TypePath') ) == child.get('_type') ){
                            var parent_link = child.get('Parent');
                            if ( parent_link ) {
                                var parent = item_hash[parent_link.ObjectID];
                                if ( parent ) {
                                    this.logger.log('calc fields:',this.calculation_fields);
                                    this.logger.log('parent: ', parent);
                                    Ext.Object.each(this.calculation_fields,function(calculation_field,calculation_header){
                                        var parent_value = parent.get(calculation_field) || 0;
                                        var child_value = child.get(calculation_field) || 0;
                                        parent.set(calculation_field,parent_value+child_value);
                                    },this);
                                }
                            }
                        }
                    },this);
                },this);
                deferred.resolve(item_hash);
            },
            failure: function(error_message) {
                deferred.reject(error_message);
            }
        });
        return deferred.promise;
    },
    _getParentTypeFor:function(type) {
        var parent_type = null;
        Ext.Array.each(this.pi_types,function(pi_type,idx) {
            if ( type == pi_type.get('TypePath') ) {
                parent_type = this.pi_types[idx+1].get('TypePath');
            }
        },this);
        return parent_type;
    },
    _loadItemsByObjectID:function(parent_oids,parent_type,children){
        var deferred = Ext.create('Deft.Deferred');
        this.logger.log("_loadItemsByObjectID",parent_type, parent_oids.length);
        
        var filters = Ext.create('Rally.data.wsapi.Filter',{property:'ObjectID',value:parent_oids[0]});

        for ( var i=1; i<parent_oids.length; i++ ) {
            filters = filters.or(Ext.create('Rally.data.wsapi.Filter',{property:'ObjectID',value:parent_oids[i]}));
        }
        
        Ext.create('Rally.data.wsapi.Store', {
            fetch: ['Name','ObjectID','FormattedID','Parent'],
            filters: filters,
            autoLoad: true,
            model: parent_type,
            listeners: {
                scope: this,
                load: function(store, records, successful) {
                    if (successful){
                        var grand_parent_oids = [];
                        Ext.Array.each(records, function(record){
                            if ( record.get('Parent')) {
                                var grand_parent_oid = record.get('Parent').ObjectID;
                                if ( grand_parent_oid ) {
                                    grand_parent_oids = Ext.Array.merge(grand_parent_oids,[grand_parent_oid]); 
                                }
                            }
                        });
                        if ( grand_parent_oids.length > 0 ) {
                            this._loadItemsByObjectID(grand_parent_oids,this._getParentTypeFor(parent_type),Ext.Array.merge(records,children)).then({
                                scope: this,
                                success: function(parents) {
                                    deferred.resolve(parents);
                                },
                                failure: function(msg) {
                                    deferred.reject(msg);
                                }
                            });
                        } else {
                            deferred.resolve(Ext.Array.merge(records,children));
                        }
                    } else {
                        deferred.reject('Failed to load parents');
                    }
                }
            }
        });
        return deferred.promise;
    },
    _getPortfolioItemTypes: function() {
        var deferred = Ext.create('Deft.Deferred');
                
        var store = Ext.create('Rally.data.wsapi.Store', {
            fetch: ['Name','ElementName','TypePath'],
            model: 'TypeDefinition',
            limit: 'Infinity',
            filters: [
                {
                    property: 'Parent.Name',
                    operator: '=',
                    value: 'Portfolio Item'
                },
                {
                    property: 'Creatable',
                    operator: '=',
                    value: 'true'
                }
            ],
            autoLoad: true,
            listeners: {
                load: function(store, records, successful) {
                    if (successful){
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Failed to load initial stories');
                    }
                }
            }
        });
                    
        return deferred.promise;
    },
    _loadStories: function(pi_field){
        var deferred = Ext.create('Deft.Deferred');
        
        var store = Ext.create('Rally.data.wsapi.Store', {
            fetch: ['Name','ObjectID','FormattedID','TaskActualTotal',
                'TaskEstimateTotal','PlanEstimate','TaskRemainingTotal',pi_field, 
                'Project','Workspace','Parent'],
            model: 'HierarchicalRequirement',
            filters: [{
                property: 'DirectChildrenCount',
                value: 0
            }],
            autoLoad: true,
            listeners: {
                load: function(store, records, successful) {
                    if (successful){
                        Ext.Array.each(records,function(record){
                            
                            record.set('workspace_name', record.get('Workspace').Name);
                            record.set('project_name', record.get('Project').Name);
                            var program_name = '--';
                            if ( record.get('Project').Parent) {
                                record.set('program_name', record.get('Project').Parent.Name);
                            }
                        });
                        deferred.resolve(records);
                    } else {
                        deferred.reject('Failed to load initial Snapshot Store');
                    }
                }
            }
        });
        return deferred.promise;
    },
    /*
     * want to have a single record per line in the grid for each story, 
     * so tack on the parent-grandparent-etc data on the story record
     */
    _consolidateParentInfoInStories: function(stories,parents){
        this.logger.log("_consolidateParentInfoInStories");
        var lowest_type = this.pi_types[0].get('ElementName');
        
        Ext.Array.each(stories, function(story) {
            this._setStoryFields(story);
            
            var parent_link = story.get(lowest_type);
            if ( parent_link ) {
                var parent_oid = parent_link.ObjectID;
                var parent = parents[parent_oid];
                story.set(lowest_type + "_FormattedID", parent.get('FormattedID'));
                story.set(lowest_type + "_ObjectID", parent.get('ObjectID'));
                story.set(lowest_type + "_Name", parent.get('Name'));
                
                Ext.Object.each(this.calculation_fields,function(calculation_field,calculation_header){
                    var parent_value = parent.get(calculation_field) || 0;
                    story.set(lowest_type + "_" + calculation_field,parent_value);
                });
                var last_parent = parent;
                for ( var i=1; i<this.pi_types.length; i++ ) {
                    var type = this.pi_types[i].get('ElementName');
                    parent_link = last_parent.get('Parent');
                    if ( parent_link ) {
                        parent_oid = parent_link.ObjectID;
                        parent = parents[parent_oid];
                        if ( parent ) {
                            story.set(type + "_FormattedID", parent.get('FormattedID'));
                            story.set(type + "_ObjectID", parent.get('ObjectID'));
                            story.set(type + "_Name", parent.get('Name'));
                            
                            Ext.Object.each(this.calculation_fields,function(calculation_field,calculation_header){
                                var parent_value = parent.get(calculation_field) || 0;
                                story.set(type + "_" + calculation_field,parent_value);
                            });
                        }
                    }
                    last_parent = parent;
                }
            }
        },this);
        
        return stories;
    },
    /*
     * Have to set the special fields on everything so that we have something to work with
     * in the custom store (it decides what the fields should be from the first object)
     */
    _setStoryFields:function(story){
        for ( var i=0; i<this.pi_types.length; i++ ) {
            var type = this.pi_types[i].get('ElementName');
            story.set(type + "_FormattedID","");
            story.set(type + "_ObjectID","");
            Ext.Object.each(this.calculation_fields,function(calculation_field,calculation_header){
                story.set(type + "_" + calculation_field,"");
            });
        }
        return story;
    },
    _isAbleToDownloadFiles: function() {
        try { 
            var isFileSaverSupported = !!new Blob(); 
        } catch(e){
            this.logger.log(" NOTE: This browser does not support downloading");
            return false;
        }
        return true;
    },
    _getCSVFromGrid:function(grid, records){
        var columns = grid.columns;
        var column_names = [];
        var headers = [];
        
        var csv = [];

        this.logger.log('columns:',columns);
        
        Ext.Array.each(columns,function(column){
            if ( column.dataIndex ) {
                column_names.push(column.dataIndex);
                if ( column.csvText ) {
                    headers.push(column.csvText);
                } else {
                    headers.push(column.text);
                }
            }
        });
        
        this.logger.log("Headers: ", headers);
        csv.push('"' + headers.join('","') + '"');
        
        Ext.Array.each(records,function(record){
            var node_values = [];
            Ext.Array.each(column_names,function(column_name){
                node_values.push(record.get(column_name));
            },this);
            csv.push('"' + node_values.join('","') + '"');
        });
        
        return csv.join('\r\n');
    },
    _saveCSVToFile:function(csv,file_name,type_object){
        var blob = new Blob([csv],type_object);
        saveAs(blob,file_name);
    }
});
            
               Rally.launchApp('CustomApp', {
                   name: 'Task Actual Rollup'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>